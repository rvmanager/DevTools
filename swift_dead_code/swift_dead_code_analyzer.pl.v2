#!/usr/bin/env perl
# swift_dead_code_analyzer.pl

use strict;
use warnings;
use File::Find;
use File::Spec;
use JSON;
use Data::Dumper;
use Getopt::Long;

# Configuration
my %config = (
    swift_frontend => '/usr/bin/xcrun swift-frontend',
    project_path => '.',
    output_format => 'json',
    include_tests => 1,
    verbose => 0,
    fallback_to_source => 1,
    sdk_path => undef
);

# Data structures
my %functions = ();      # function_id => { name, file, line, type, visibility }
my %call_graph = ();     # caller_id => [callee_id, ...]
my %reverse_calls = ();  # callee_id => [caller_id, ...]
my @entry_points = ();   # [function_id, ...]

sub extract_ast_from_file {
    my ($swift_file) = @_;
    
    # Try multiple approaches for getting Swift AST
    my @commands = (
        # Use xcrun with proper SDK path
        "xcrun -sdk macosx swift-frontend -frontend -dump-ast -primary-file \"$swift_file\"",
        # Alternative with explicit SDK
        "xcrun swift-frontend -frontend -dump-ast -sdk \$(xcrun --show-sdk-path) -primary-file \"$swift_file\"",
        # Use swiftc with dump-ast (newer approach)
        "xcrun swiftc -dump-ast \"$swift_file\"",
        # Fallback to source parsing if AST fails
        ""
    );
    
    if ($config{verbose}) {
        print "Parsing: $swift_file\n";
    }
    
    for my $cmd (@commands) {
        next if $cmd eq "";
        
        if ($config{verbose} > 1) {
            print "  Trying: $cmd\n";
        }
        
        open(my $ast_fh, '-|', "$cmd 2>/dev/null") or next;
        my $ast_content = do { local $/; <$ast_fh> };
        close($ast_fh);
        
        # Check if we got valid AST output
        if ($ast_content && $ast_content =~ /\(source_file/) {
            return $ast_content;
        }
    }
    
    # Fallback: parse source directly
    if ($config{verbose}) {
        print "  AST extraction failed, falling back to source parsing\n";
    }
    return parse_source_directly($swift_file);
}

sub parse_source_directly {
    my ($swift_file) = @_;
    
    open(my $fh, '<', $swift_file) or die "Cannot open $swift_file: $!";
    my $content = do { local $/; <$fh> };
    close($fh);
    
    return $content;
}

sub parse_functions_from_ast {
    my ($content, $file_path) = @_;
    my @found_functions = ();
    
    # Determine if this is AST output or source code
    my $is_ast = ($content =~ /\(source_file/);
    
    if ($is_ast) {
        return parse_functions_from_real_ast($content, $file_path);
    } else {
        return parse_functions_from_source($content, $file_path);
    }
}

sub parse_functions_from_real_ast {
    my ($ast_content, $file_path) = @_;
    my @found_functions = ();
    
    # Parse function declarations from AST
    while ($ast_content =~ /\(func_decl\s+"([^"]+)"\s+.*?interface\s+type='([^']+)'/g) {
        my ($func_name, $type_info) = ($1, $2);
        
        # Extract line number if available
        my $line_num = 1;
        if ($ast_content =~ /\@([^:]+):(\d+)/) {
            $line_num = $2;
        }
        
        my $function_id = generate_function_id($func_name, $file_path, $line_num);
        
        $functions{$function_id} = {
            name => $func_name,
            file => $file_path,
            line => $line_num,
            type => $type_info,
            visibility => extract_visibility_from_ast($ast_content, $func_name)
        };
        
        push @found_functions, $function_id;
        
        # Check if this is an entry point
        if (is_entry_point($func_name, $type_info, $file_path)) {
            push @entry_points, $function_id;
        }
    }
    
    # Parse method declarations in classes/structs
    while ($ast_content =~ /\(class_decl\s+"([^"]+)".*?\(func_decl\s+"([^"]+)"/gs) {
        my ($class_name, $method_name) = ($1, $2);
        my $full_name = "$class_name.$method_name";
        
        my $function_id = generate_function_id($full_name, $file_path);
        
        $functions{$function_id} = {
            name => $full_name,
            file => $file_path,
            line => extract_line_number($ast_content),
            type => 'method',
            visibility => extract_visibility_from_ast($ast_content, $method_name)
        };
        
        push @found_functions, $function_id;
    }
    
    return @found_functions;
}

sub parse_functions_from_source {
    my ($source_content, $file_path) = @_;
    my @found_functions = ();
    my @lines = split /\n/, $source_content;
    
    for my $line_num (0..$#lines) {
        my $line = $lines[$line_num];
        
        # Skip comments and empty lines
        next if $line =~ /^\s*\/\// || $line =~ /^\s*$/;
        
        # Parse function declarations
        if ($line =~ /^\s*(public|internal|private|fileprivate)?\s*func\s+([^\s(]+)\s*\(/) {
            my ($visibility, $func_name) = ($1 || 'internal', $2);
            
            my $function_id = generate_function_id($func_name, $file_path, $line_num + 1);
            
            $functions{$function_id} = {
                name => $func_name,
                file => $file_path,
                line => $line_num + 1,
                type => 'function',
                visibility => $visibility
            };
            
            push @found_functions, $function_id;
            
            # Check if this is an entry point
            if (is_entry_point($func_name, $visibility, $file_path)) {
                push @entry_points, $function_id;
            }
        }
        
        # Parse method declarations in classes/structs/enums
        elsif ($line =~ /^\s*(class|struct|enum)\s+([^\s{:]+)/) {
            my ($type, $class_name) = ($1, $2);
            my $class_start = $line_num;
            
            # Find the closing brace for this class
            my $brace_count = 0;
            my $in_class = 0;
            
            for my $i ($class_start..$#lines) {
                my $class_line = $lines[$i];
                
                # Count braces to find class boundaries
                $brace_count += ($class_line =~ tr/{/{/);
                $brace_count -= ($class_line =~ tr/}/}/);
                
                if ($class_line =~ /{/) {
                    $in_class = 1;
                }
                
                if ($in_class && $class_line =~ /^\s*(public|internal|private|fileprivate)?\s*func\s+([^\s(]+)\s*\(/) {
                    my ($method_visibility, $method_name) = ($1 || 'internal', $2);
                    my $full_name = "$class_name.$method_name";
                    
                    my $function_id = generate_function_id($full_name, $file_path, $i + 1);
                    
                    $functions{$function_id} = {
                        name => $full_name,
                        file => $file_path,
                        line => $i + 1,
                        type => 'method',
                        visibility => $method_visibility,
                        parent_class => $class_name
                    };
                    
                    push @found_functions, $function_id;
                    
                    # Check if this is an entry point
                    if (is_entry_point($method_name, $method_visibility, $file_path, $class_name)) {
                        push @entry_points, $function_id;
                    }
                }
                
                # Exit when we've closed all braces
                last if $in_class && $brace_count == 0;
            }
        }
        
        # Parse initializers
        elsif ($line =~ /^\s*(public|internal|private|fileprivate)?\s*init\s*\(/) {
            my $visibility = $1 || 'internal';
            my $function_id = generate_function_id('init', $file_path, $line_num + 1);
            
            $functions{$function_id} = {
                name => 'init',
                file => $file_path,
                line => $line_num + 1,
                type => 'initializer',
                visibility => $visibility
            };
            
            push @found_functions, $function_id;
        }
    }
    
    return @found_functions;
}

sub parse_function_calls_from_ast {
    my ($content, $file_path, $functions_in_file) = @_;
    
    # Determine if this is AST output or source code
    my $is_ast = ($content =~ /\(source_file/);
    
    if ($is_ast) {
        parse_calls_from_real_ast($content, $file_path);
    } else {
        parse_calls_from_source($content, $file_path);
    }
}

sub parse_calls_from_real_ast {
    my ($ast_content, $file_path) = @_;
    
    if ($config{verbose} > 1) {
        print "  Parsing function calls from AST for $file_path\n";
    }
    
    # Pattern for function calls in AST: (call_expr type='...' (declref_expr "functionName")
    my $call_count = 0;
    while ($ast_content =~ /\(call_expr[^)]*?\(declref_expr\s+"([^"]+)"/gs) {
        my $called_function = $1;
        $call_count++;
        
        # Find the calling function context by looking backwards in the AST
        my $calling_function = find_calling_function_context($ast_content, pos($ast_content));
        
        if ($calling_function) {
            my $caller_id = find_function_id_by_name($calling_function, $file_path);
            my $callee_id = find_function_id_by_name($called_function);
            
            if ($caller_id && $callee_id) {
                push @{$call_graph{$caller_id}}, $callee_id;
                if ($config{verbose} > 2) {
                    print "    Call: $calling_function -> $called_function\n";
                }
            }
        }
    }
    
    # Pattern for method calls: (call_expr (dot_syntax_call_expr (declref_expr) (declref_expr "methodName")
    while ($ast_content =~ /\(call_expr[^)]*?\(dot_syntax_call_expr[^)]*?\(declref_expr[^)]*?\)\s*\(declref_expr\s+"([^"]+)"/gs) {
        my $called_method = $1;
        $call_count++;
        
        my $calling_function = find_calling_function_context($ast_content, pos($ast_content));
        
        if ($calling_function) {
            my $caller_id = find_function_id_by_name($calling_function, $file_path);
            
            # Try to find the method in our function list (could be Class.method)
            for my $func_id (keys %functions) {
                if ($functions{$func_id}->{name} =~ /\.\Q$called_method\E$/) {
                    push @{$call_graph{$caller_id}}, $func_id;
                    if ($config{verbose} > 2) {
                        print "    Method call: $calling_function -> $functions{$func_id}->{name}\n";
                    }
                    last;
                }
            }
        }
    }
    
    if ($config{verbose} > 1) {
        print "  Found $call_count function calls in AST\n";
    }
}

sub parse_calls_from_source {
    my ($source_content, $file_path) = @_;
    my @lines = split /\n/, $source_content;
    my $current_function = '';
    
    for my $line_num (0..$#lines) {
        my $line = $lines[$line_num];
        
        # Track which function we're currently in
        if ($line =~ /^\s*(?:public|internal|private|fileprivate)?\s*func\s+([^\s(]+)\s*\(/) {
            $current_function = $1;
        }
        elsif ($line =~ /^\s*(?:class|struct|enum)\s+([^\s{:]+)/) {
            my $class_name = $1;
            # Look ahead for methods in this class
            my $brace_count = 0;
            my $in_class = 0;
            
            for my $i ($line_num..$#lines) {
                my $class_line = $lines[$i];
                
                $brace_count += ($class_line =~ tr/{/{/);
                $brace_count -= ($class_line =~ tr/}/}/);
                
                if ($class_line =~ /{/) {
                    $in_class = 1;
                }
                
                if ($in_class && $class_line =~ /^\s*(?:public|internal|private|fileprivate)?\s*func\s+([^\s(]+)\s*\(/) {
                    $current_function = "$class_name.$1";
                    last;
                }
                
                last if $in_class && $brace_count == 0;
            }
        }
        
        # Look for function calls in the current line
        # Simple pattern matching for function calls
        while ($line =~ /\b([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g) {
            my $called_function = $1;
            
            # Skip common Swift keywords and operators
            next if $called_function =~ /^(if|for|while|switch|guard|let|var|func|class|struct|enum|return|print|import)$/;
            
            if ($current_function) {
                my $caller_id = find_function_id_by_name($current_function, $file_path);
                my $callee_id = find_function_id_by_name($called_function);
                
                if ($caller_id && $callee_id) {
                    push @{$call_graph{$caller_id}}, $callee_id;
                    # Don't add to reverse_calls here, we'll build it later
                }
            }
        }
        
        # Look for method calls (object.method())
        while ($line =~ /\.([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g) {
            my $called_method = $1;
            
            if ($current_function) {
                my $caller_id = find_function_id_by_name($current_function, $file_path);
                
                # Try to find the method in our function list
                for my $func_id (keys %functions) {
                    if ($functions{$func_id}->{name} =~ /\.$called_method$/) {
                        push @{$call_graph{$caller_id}}, $func_id;
                        last;
                    }
                }
            }
        }
    }
}

sub generate_function_id {
    my ($name, $file, $line) = @_;
    $line //= 0;
    return "$file:$line:$name";
}

sub is_entry_point {
    my ($func_name, $type_info, $file_path, $class_name) = @_;
    
    # Main function
    return 1 if $func_name eq 'main';
    
    # @main attributed types
    return 1 if $type_info =~ /\@main/;
    
    # Test functions
    return 1 if $func_name =~ /^test/ && $file_path =~ /test/i;
    
    # UIApplicationMain or similar
    return 1 if $func_name =~ /^(applicationDidFinishLaunching|application.*)/;
    
    # SwiftUI App protocol conformance
    return 1 if $func_name eq 'body' && $class_name && $class_name =~ /App$/;
    
    # View body properties (SwiftUI)
    return 1 if $func_name eq 'body' && $file_path =~ /View\.swift$/i;
    
    # Public functions in framework context
    return 1 if $type_info =~ /public/ || $type_info eq 'public';
    
    # @objc methods (could be called from Objective-C)
    return 1 if $type_info =~ /\@objc/;
    
    # @IBAction methods (connected to Interface Builder)
    return 1 if $type_info =~ /\@IBAction/;
    
    # @IBOutlet properties (connected to Interface Builder)
    return 1 if $type_info =~ /\@IBOutlet/;
    
    # Common lifecycle methods
    return 1 if $func_name =~ /^(viewDidLoad|viewWillAppear|viewDidAppear|viewWillDisappear|viewDidDisappear|loadView)$/;
    
    # Delegate methods
    return 1 if $func_name =~ /^(delegate|dataSource)/i;
    
    return 0;
}

sub build_reverse_call_graph {
    %reverse_calls = ();
    
    for my $caller_id (keys %call_graph) {
        for my $callee_id (@{$call_graph{$caller_id}}) {
            push @{$reverse_calls{$callee_id}}, $caller_id;
        }
    }
}

sub find_reachable_functions {
    my @reachable = ();
    my %visited = ();
    my @queue = @entry_points;
    
    while (@queue) {
        my $current = shift @queue;
        next if $visited{$current};
        
        $visited{$current} = 1;
        push @reachable, $current;
        
        # Add all functions called by this function
        if ($call_graph{$current}) {
            for my $callee (@{$call_graph{$current}}) {
                push @queue, $callee unless $visited{$callee};
            }
        }
    }
    
    return @reachable;
}

sub find_dead_code {
    my @reachable = find_reachable_functions();
    my %reachable_set = map { $_ => 1 } @reachable;
    
    my @dead_functions = ();
    for my $func_id (keys %functions) {
        unless ($reachable_set{$func_id}) {
            push @dead_functions, $func_id;
        }
    }
    
    return @dead_functions;
}

sub analyze_project {
    my ($project_path) = @_;
    
    print "Analyzing Swift project at: $project_path\n" if $config{verbose};
    
    # Find all Swift files
    my @swift_files = ();
    find(sub {
        push @swift_files, $File::Find::name if /\.swift$/;
    }, $project_path);
    
    print "Found " . scalar(@swift_files) . " Swift files\n" if $config{verbose};
    
    my $success_count = 0;
    my $total_files = scalar(@swift_files);
    
    # Phase 1: Extract all functions
    for my $file (@swift_files) {
        eval {
            my $content = extract_ast_from_file($file);
            if ($content) {
                my @file_functions = parse_functions_from_ast($content, $file);
                
                # Phase 2: Extract function calls
                parse_function_calls_from_ast($content, $file, \@file_functions);
                $success_count++;
            }
        };
        
        if ($@) {
            print "Warning: Failed to parse $file: $@\n" if $config{verbose};
        }
    }
    
    print "Successfully parsed $success_count of $total_files files\n" if $config{verbose};
    print "Total functions found: " . scalar(keys %functions) . "\n" if $config{verbose};
    print "Entry points found: " . scalar(@entry_points) . "\n" if $config{verbose};
    
    if ($config{verbose} > 1) {
        print "Entry points:\n";
        for my $entry (@entry_points) {
            print "  - $functions{$entry}->{name} ($entry)\n";
        }
    }
    
    # Phase 3: Build reverse call graph
    build_reverse_call_graph();
    print "Call graph edges: " . scalar(keys %call_graph) . "\n" if $config{verbose};
    
    # Phase 4: Find dead code
    my @dead_functions = find_dead_code();
    
    return @dead_functions;
}

sub generate_report {
    my (@dead_functions) = @_;
    
    if ($config{output_format} eq 'json') {
        my @report_data = ();
        for my $func_id (@dead_functions) {
            my $func_info = $functions{$func_id};
            push @report_data, {
                function => $func_info->{name},
                file => $func_info->{file},
                line => $func_info->{line},
                type => $func_info->{type},
                visibility => $func_info->{visibility}
            };
        }
        
        print encode_json({
            summary => {
                total_functions => scalar(keys %functions),
                dead_functions => scalar(@dead_functions),
                entry_points => scalar(@entry_points)
            },
            dead_code => \@report_data
        });
    } else {
        print "=== Swift Dead Code Analysis Report ===\n\n";
        print "Total functions analyzed: " . scalar(keys %functions) . "\n";
        print "Entry points found: " . scalar(@entry_points) . "\n";
        print "Dead functions found: " . scalar(@dead_functions) . "\n\n";
        
        print "Dead Code:\n";
        print "-" x 50 . "\n";
        
        for my $func_id (@dead_functions) {
            my $func = $functions{$func_id};
            print sprintf("%-30s %s:%d\n", $func->{name}, $func->{file}, $func->{line});
        }
    }
}

# Helper functions
sub extract_visibility {
    my ($ast_content, $func_name) = @_;
    
    # Look for visibility modifiers before function declaration
    if ($ast_content =~ /\b(public|internal|fileprivate|private)\s+.*func\s+$func_name/) {
        return $1;
    }
    
    return 'internal'; # default visibility
}

# Add helper function for visibility extraction
sub extract_visibility_from_ast {
    my ($ast_content, $func_name) = @_;
    return extract_visibility($ast_content, $func_name);
}

sub extract_line_number {
    my ($content) = @_;
    # This is a simplified implementation
    return 1;
}

sub find_function_id_by_name {
    my ($func_name, $file_hint) = @_;
    
    # Try exact match first
    for my $func_id (keys %functions) {
        return $func_id if $functions{$func_id}->{name} eq $func_name;
    }
    
    # Try fuzzy match within same file if hint provided
    if ($file_hint) {
        for my $func_id (keys %functions) {
            if ($functions{$func_id}->{file} eq $file_hint && 
                $functions{$func_id}->{name} =~ /\Q$func_name\E/) {
                return $func_id;
            }
        }
    }
    
    return undef;
}

sub find_calling_function_context {
    my ($ast_content, $position) = @_;
    
    # This is a simplified implementation
    # In practice, you'd need more sophisticated AST traversal
    my $before_content = substr($ast_content, 0, $position);
    
    # Find the last function declaration before this position
    if ($before_content =~ /.*\(func_decl\s+"([^"]+)"/s) {
        return $1;
    }
    
    return undef;
}

# Main execution
sub main {
    GetOptions(
        'project-path=s' => \$config{project_path},
        'output=s' => \$config{output_format},
        'include-tests!' => \$config{include_tests},
        'verbose!' => \$config{verbose},
        'help' => sub { print_usage(); exit 0; }
    );
    
    my @dead_functions = analyze_project($config{project_path});
    generate_report(@dead_functions);
}

sub print_usage {
    print <<EOF;
Usage: swift_dead_code_analyzer.pl [OPTIONS]

Options:
    --project-path PATH    Path to Swift project (default: current directory)
    --output FORMAT        Output format: text|json (default: json)
    --include-tests        Include test functions as entry points
    --no-include-tests     Exclude test functions from entry points
    --verbose              Enable verbose output
    --help                 Show this help message

Examples:
    swift_dead_code_analyzer.pl --project-path ./MySwiftApp
    swift_dead_code_analyzer.pl --output text --verbose
    swift_dead_code_analyzer.pl --no-include-tests
EOF
}

main() unless caller;

1;
